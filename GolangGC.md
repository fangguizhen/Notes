# Golang GC
## 一、引用计数

* 思想：每个单元维护一个域，保存其他单元指向它的引用数量。当引用数量为0时，将其回收。
* 实现：引用计数算法一般是把所有的单元放在一个单元池中新分配的单元计数值被设置为1；每次有一个指针被设为指向该单元时，该单元的计数值加1；删除时减1。引用计数是渐进式的，能够将内存管理的开销分布到整个程序中。

## 二、标记-清扫

* 标记-清扫算法是第一种自动内存管理，基于追踪的垃圾收集算法。内存单元不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，也就是STW，转而执行垃圾回收程序。垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。

* 算法分两个部分：标记和清扫。标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收。

* 优点：可以处理循环引用。

* 缺点：需要STW

* 三色标记算法是对标记阶段的改进，原理如下：

  * 1、起初所有的对象都是白色。

  * 2、从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
  * 3、从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
  * 4、重复3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

## 三、节点复制

* 节点复制也是基于追踪的算法。其将整个堆分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。后面不理解了。。
* 缺点：总有一半的内存空间浪费。

## 四、分代收集

* 基于追踪的垃圾回收算法一个主要问题就是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的同时，内存分配存在“most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个区（或者更多）区域。这些区域就是分代（generation）。分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫promote。随着不断promote，最后新生代的大小在整个堆的占用比例不会特别大。STW的时间也会更短。
* 优点：性能更优
* 缺点：实现复杂

## 问题反馈
* 邮件:[qq邮箱](1297394526@qq.com)
* QQ:1297394526
* Github: [@fangguizhen](https://github.com/fangguizhen)
